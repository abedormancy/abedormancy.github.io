<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[03.用私有构造器或枚举类实现单例]]></title>
    <url>%2F2018%2F08%2F21%2F03-%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Singleton(单例) 指的是仅仅只会被实例化一次的类。通常用来表示无状态对象，例如 function (.24) 或本质上唯一的系统组件。这里不打算讲设计模式中单例模式的什么饿汉，懒汉，DCL（双检锁）等等，有兴趣的可以自己上网搜索。 effective java 中提出了三种方法实现 Singleton 。 第一种直接使用公有域。 1234567public class Singleton &#123; public static final Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125;; public void leaveTheBuilder() &#123; //... &#125;&#125; 第二种使用公有静态工厂方法。 12345678910public class Singleton &#123; private static final Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; return INSTANCE; &#125; public void leaveTheBuilding() &#123; //... &#125;&#125; 第二种有个主要优势是可以使用方法引用，例如：Supplier&lt;Singleton&gt; singleton = Singleton::getInstance; 以上两种如果不对私有构造器做处理的话，享有特权的客户端可以借助 AccessibleObject.setAccessible 方法通过反射 (.65) 机制调用私有构造器。如果要防御这种攻击，可以修改私有构造器，在生成第二个对象时抛出异常。这两种如果要实现序列化还比较麻烦，不仅在类声明上需要 “implements Serializable” ，并且必须声明所有的实例域都是瞬时 (transient) 的，还要提供一个 readResolve (.89) 方法。 123private Object readResolve() &#123; return INSTANCE;&#125; 第三种方式是使用单元素枚举类。 123456public enum Singleton &#123; INSTANCE; public void leaveTheBuilding() &#123; //... &#125;&#125; 该方式无偿的提供了序列化机制，并且防止多次实例化，即使面对复杂的序列化或反射攻击的时候。 Josh Bloch 大大给出的结论是，单元素枚举类是实现单例的最佳方法。 但有一点请注意，如果你的单例类需要继承非枚举的超类，那么你就不可以用这个方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.面对多个参数的构造器(Constractor)要考虑使用构建器(Builder)]]></title>
    <url>%2F2018%2F08%2F20%2F02-%E9%9D%A2%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8-Constractor-%E8%A6%81%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8-Builder%2F</url>
    <content type="text"><![CDATA[Builder 模式就不做过多介绍了，在设计那些构造函数或静态工厂有多个参数的类时，构建器模式是一个很好的选择，尤其是当许多参数是可选的或类型相同时。Builder 比 JaveBeans 更安全。 缺点是写起来比较麻烦，好在我们有 Lombok 神器帮我们自动生成。 构建器模式还非常适用类层次结构，下面是一个书中的一个例子： Pizza.java 1234567891011121314151617181920212223242526272829303132package effectivejava.chapter2.item2.hierarchicalbuilder;import java.util.*;// Note that the underlying "simulated self-type" idiom allows for arbitrary fluid hierarchies, not just builderspublic abstract class Pizza &#123; public enum Topping &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125; final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123; EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) &#123; toppings.add(Objects.requireNonNull(topping)); return self(); &#125; abstract Pizza build(); // Subclasses must override this method to return "this" protected abstract T self(); &#125; Pizza(Builder&lt;?&gt; builder) &#123; toppings = builder.toppings.clone(); // See Item 50 &#125;&#125; 注意 Pizza.Builder 是具有递归类型参数的泛型 (.30)，self() 可以正常的返回子类型对象而不需要显示的强制转换，是一种惯用的解决 java 缺乏自我类型的变通方法。 NyPizza.java 12345678910111213141516171819202122232425262728293031323334353637383940package effectivejava.chapter2.item2.hierarchicalbuilder;import java.util.Objects;public class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private final Size size; public Builder(Size size) &#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private NyPizza(Builder builder) &#123; super(builder); size = builder.size; &#125; @Override public String toString() &#123; return "New York Pizza with " + toppings; &#125;&#125; Calzone.java 1234567891011121314151617181920212223242526272829303132333435package effectivejava.chapter2.item2.hierarchicalbuilder;public class Calzone extends Pizza &#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; // Default public Builder sauceInside() &#123; sauceInside = true; return this; &#125; @Override public Calzone build() &#123; return new Calzone(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private Calzone(Builder builder) &#123; super(builder); sauceInside = builder.sauceInside; &#125; @Override public String toString() &#123; return String.format("Calzone with %s and sauce on the %s", toppings, sauceInside ? "inside" : "outside"); &#125;&#125; 注意以上两个子类 Builder 中的 build() 方法，它们都返回了实际的类，这种技术称为协变返回类型( covariant return typing)，允许客户端不需要转换直接使用这些builders，下面看客户端代码。 PizzaTest 12345678910111213141516package effectivejava.chapter2.item2.hierarchicalbuilder;import static effectivejava.chapter2.item2.hierarchicalbuilder.Pizza.Topping.*;import static effectivejava.chapter2.item2.hierarchicalbuilder.NyPizza.Size.*;public class PizzaTest &#123; public static void main(String[] args) &#123; NyPizza pizza = new NyPizza.Builder(SMALL) .addTopping(SAUSAGE).addTopping(ONION).build(); Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInside().build(); System.out.println(pizza); System.out.println(calzone); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.考虑使用静态工厂方法代替构造器]]></title>
    <url>%2F2018%2F08%2F18%2F01-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[优点 有名称 在含有相同签名的多个构造函数的情况下，使用不同名称的静态工厂方法会让API更具可读性。例如：BigInteger 中的一个构造函数 BigInteger(int, int, Random) 返回的 BigInteger 可能为素数，但如果使用 BigInteger.probablePrime 静态工厂方法来表示更为清楚。 不需要每次调用时都创建一个新的对象 允许不可变类 (.17) 使用预先构造的实例，或在构造时将实例缓存起来进行重复利用，从而避免创建不必要的重复对象。 可以返回该类型的任意子类型对象 可以灵活的选择返回该类的对象，一个比较常见的应用是 API 可以返回对象且不会让此对象的类变成公有的，这样可以隐藏实现类，此技术适用于基于接口的框架 (.20) 。在 java8 之前接口不能有静态方法，按照惯例，Type 接口通过不可实例化的 Types 类导出其静态方法，一个具体的列子是 Collection 接口 与 Collections 类。还有一点，这样可以强制让用户通过接口来引用被返回的对象，这通常是最佳实践 (.64) 。在 java8 中接口已经可以含有静态方法，许多静态成员应该被放置在接口本身中。然而，仍有必要将大部分实现代码放在单独包的私有类中而不是接口的静态方法，这是因为 java8 中要求所有静态成员是公开的。java9 允许私有静态方法，但静态字段和静态成员类仍然需要公开。 返回的类可以根据调用参数而进行变化 这点其实是上面那点的引申，参考 EnumSet (.36) ，它没有构造器，只有静态工厂方法，通过参数来决定返回适合当前参数最优的子类，返回的实现类可以随着版本的迭代有多种不同选择，未来如果发现哪个实现类不适合了，完全可以干掉，并且不会对客户端造成任何影响。 在编写静态工厂方法的时候，被返回的实现类不需要存在 这种灵活的静态工厂方法构成了服务提供者框架 的基础，例如 JDBC API。 服务提供者框架 中有三个基础组件： ​ 服务接口 ( service interface ) ：代表实现的服务接口。 ​ 提供者注册API ( provider registration API ) ：提供者用来注册和实现。 ​ 服务访问API ( service access API ) ：客户端用来访问服务实例，允许客户端指定选择实现的标准，如果没有这样的标准，API 会返回默认实现的实例，或允许客户端循环查看所有可用的实现。它是构成服务提供者框架基础的灵活静态工厂。 及一个可选组件： ​ 服务提供者接口 ( service provider interface ) ：描述了产生服务接口实例的工厂对象。在没有此接口的情况下，实现就必须通过反射实例化 对于 JDBC 来说 ，Connection 扮演一部分服务接口角色，DriverManager.registerDriver 是提供者注册API，DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。服务提供者框架 模式有很多种变体。例如服务访问API返回比提供者提供的更为丰富的服务接口。这就是桥接模式。依赖注入框架可以被看作是强力服务提供者。java6 平台包含了一个通用的服务提供者框架 java.util.ServiceLoader ，所以你不必，通常也不应该自己写一个。JDBC 没有使用 ServiceLoader 的原因是因为 JDBC 比 ServiceLoader 更早。 缺点 仅提供静态工厂方法的主要限制是没有 public 或 protected 构造器的类无法被子类化 一个类不能被子类化也许会因祸得福，因为它鼓励程序员使用复合代替继承 (.18) ,并且对不可变类型 (.17) 来说这是必须的。 程序员不容易找到它 静态工厂方法和普通的静态方法没有什么区别，很难在 API 脱颖而出，所以程序员不太容易知道这个类是否提供静态工厂方法。可以通过关注类或接口的文档并且遵守命名习惯来弥补。以下是用于静态工厂方法的一些常用名称： from - 一种类型转换方法，通过一个参数返回对应类的实例，例如： 1Date d = Date.from(instant); of - 一种聚合方法，通过多个参数并返回包含这种参数的类型，例如： 1Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf - 一种比 from 和 of 更为冗长的方案，例如： 1BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); intance or getInstance - 返回由其参数（如果有）描述的实例，但不能说该实例与参数具有相同的值，例如： 1StackWalker luke = StackWalker.getInstance(options); create or newInstance - 同上，除了保证每个调用都会返回一个新的实例，例如： 1Object newArray = Array.newInstance(classObject, arrayLen); getType - 类似 getInstance ，但一般不是在该类中定义。Type 代表该静态工厂方法返回的对象类型，例如： 1FileStore fs = Files.getFileStore(path); newType - 同上，但保证会返回一个新的实例，例如： 1BufferedReader br = Files.newBufferedReader(path); type - 一个简单的 getType 和 newType 的替代方案，例如： 1List&lt;Complain&gt; litany = Collections.list(legacyLitany); 总之，静态工厂方法更可取，所以要避免第一反应就提供公共构造器而不首先考虑静态工厂方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test5]]></title>
    <url>%2F2017%2F06%2F11%2FTest5%2F</url>
    <content type="text"><![CDATA[2017-6-11 14:53:23 。。。。。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>