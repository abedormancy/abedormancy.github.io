<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[07.消除过期的对象引用]]></title>
    <url>%2F2018%2F08%2F26%2F07-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[先来看这样一个简单的栈实现例子。 123456789101112131415161718192021222324252627282930public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if (size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /*** * Ensure space for at least one more element, roughly* doubling the capacity * each time the array needs to grow. */ private void ensureCapacity() &#123; if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 不严格的来说，这段程序隐藏着”内存泄露“。在极端情况下，会引起磁盘分页 (disk paging)，甚至导致 OOM (OutOfMemoryError)，虽然这种失败的情况相对比较少见。 栈先通过 ensureCapacity() 方法增长后，再收缩，那么从栈中弹出的这些对象即使被客户端不再引用，它们也不会被当做垃圾回收掉。这是因为栈内部维护着这些对象的过期引用( obsolete reference )，过期引用是指永远也不会再被解除的引用。 在支持 GC 的语言中，内存泄露是很隐蔽的（称这类内存泄露为“无意识的对象保持”更为恰当）。如果一个对象引用被无意识的保留起来，那么 GC 不仅不会处理这个对象，而且也不会处理被这个对象所引用的对象，从而对性能造成潜在的影响。 这类问题的解决办法很简单：一旦对象引用过期后，只需要将指向它的引用置空即可。对于上述的例子，弹出栈顶元素后指向它的引用就过期了。 修订后的 pop() 方法如下： 1234567public Object pop() &#123; if (size == 0) throw new EmptyStackException(); Object obj = elements[--size]; elements[size] = null; return obj;&#125; 清除过期引用还有一个好处是，如果它们以后被不小心错误的引用了，会抛出 NPE，而不是悄悄地错误运行下去，尽快检测出程序中的错误中是好的。 那么我们是否需要将不再用到的对象引用都清空？其实没有必要这样做，清空对象引用只是一种例外情况，而不是一种规范。消除过期引用的最好方法是让包含该引用的变量结束其声明周期。例如你在一个紧凑的作用域范围定义的每一个变量，它们会自然而然的被消除。 那到底什么时候该清空引用？问题在于 Stack 类自己管理内存。存储池包含了 elements 数组（对象的引用，而不是对象本身）的元素。数组的活动区域 ( 0 ~ size ) 的元素是已分配的 ( allocated )，而数组的其余部分则是自由 ( free ) 的。对 GC 来说，整个 elements 数组中的所有对象引用同等有效，只有程序员知道这些非活动部分已经没有用处了。所以程序员应该通过显示的清空数组元素来告诉 GC，GC 才知道这些非活动部分可以被回收。 所以当一个类自己管理内存时，程序员应该警惕内存泄露问题。 内存泄露的另一种常见来源是缓存。一旦你把对象引用放到缓存中，它就很容易被遗忘掉。对于这种问题，有几个解决方案。例如 WeakHashMap 中的 entry 的生命周期是由外部对其 key 的引用来决定，记住如果 entry 的期望寿命是由外部引用的 key ，而不是 value 时，才可以用 WeakHashMap。 更常见的是缓存有用的生命周期不太好定义，随着时间推移，entry 的价值会变得越来越低。在这种情况下可以通过后台线程（也许是 ScheduledThreadPoolExecutor）来清除已经废弃的 entry。也可以通过向缓存中添加新条目时顺便清理。LinkedHashMap 使用 removeEldestEntry 方法实现了后一种方案。对于更复杂的缓存，可能需要使用java.lang.ref。 第三个常见的内存泄露来源是监听器和其他回调，如果你实现了一个 API ，客户端在这个 API 中注册回调，却没注销，除非你采取一些措施，否则回调会积累起来。确保回调被及时被当做垃圾回收的最佳做法是只保存它们的弱引用 ( weak reference )，例如只将它们作为键存储在 WeakHashMap 中。 关于 java 中的强、软、弱、虚等引用可以参考 Java 如何有效避免OOM]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.避免创建不必要的对象]]></title>
    <url>%2F2018%2F08%2F24%2F06-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[通常来说，重用一个对象比创建一个对象合适，毕竟重用的对象更快。如果对象是不可变的，那么总是可以重用它的。下面来看个极端的例子。 1String s = new String("hello"); // 不要这样做 相信大部分人也不会这么写，如果上面代码被频繁调用，那么它会频繁的创建新的 String 对象，但这其实是没有必要的。我们知道 String 是不可变的，所以我们只需要 1String s = "hello"; 即可。此外，jvm 还会将 “hello” 放入字符串常量池，对于所有运行在同一虚拟机上的代码，只要它们包含相同的字符串字面量，该对象就会被重用。 一般来说，如果一个类提供工厂方法，那么我们应该去使用工厂方法而不是构造器来获取对象。就拿包装类 Integer 来说，它提供了一个 valueOf 的静态工厂方法来获取类的实例，例如： 1234Integer number = Integer.valueOf(15);// Integer number = 15; // 通常我们使用这种形式，这其实和上面是等价的// Integer number = new Integer(15); // java9 中已经被弃用了，程序员不应该直接使用它。 通过查看 Integer.valueOf 的代码 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 我们可以知道 Integer 其实是有缓存的。如果数值在缓存内是会直接返回缓存中的实例，否则才会通过构造器新建。 ( 默认情况下，Integer会缓存 byte 位的数值，也就是 ~128 - 127) 一般对象的创建并不像基本类型的包装类这样来的简单，它们创建的代价通常比较昂贵。来看下面一个例子，我们需要一个方法，它通过正则检查一个参数是否是罗马数字。 123public static boolean isRomanNumeral(String s) &#123; return s.matches("^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)" + "(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$");&#125; 从直觉上来说并没有什么问题对不对，毕竟 String 类中有这样一个检查字符串与当前正则是否匹配的成员方法可以直接拿来用。但其实这个方法并不适合在性能临界的的情况下重复使用，我们来看下 String.matches 的源码就知道。 123public boolean matches(String regex) &#123; return Pattern.matches(regex, this);&#125; 它这里直接引用了 Pattern.matches 这个静态方法，而 Pattern.matches 的实现如下： 12345public static boolean matches(String regex, CharSequence input) &#123; Pattern p = Pattern.compile(regex); // = new Pattern(regex, 0); Matcher m = p.matcher(input); return m.matches();&#125; 可以看到它其实是每次都创建了新的 Pattern 实例来检测，为 Pattern 创建实例代价其实是昂贵的，因为它需要将正则表达式编译成有限状态机。为了重用，我们一般会这样： 1234567891011import java.util.regex.Pattern;//Reusing expensive object for improved performancepublic class RomanNumerals &#123; private static final Pattern ROMAN = Pattern .compile("^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)" + "(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"); public static boolean isRomanNumeral(String s) &#123; return ROMAN.matcher(s).matches(); &#125;&#125; 如果经常调用，相比之下改进的版本会有显著的性能提升。 讲到这里，要提醒一点，项目里经常看到有人如下类似的写法： 12345private static final SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");public static String format(Date date) &#123; return sf.format(date);&#125; 看起来好像没什么问题对不对，这不是类似的吗，把这个 SimpleDateFormat 缓存起来复用了，不用每次创建新的实例，提升性能。 emm… ，性能是提升了。但在多线程环境下不能这样做，我们看下 SImpleDateFormat 源码内部的注释就知道了 1234* Date formats are not synchronized.* It is recommended to create separate format instances for each thread.* If multiple threads access a format concurrently, it must be synchronized* externally. 非同步，建议为每个线程创建单独的 format 实例，如果多个线程访问一个 format 实例，那么必须同步。主要是因为 format 方法使用到了对象的可变的成员域，多线程同时修改让其变得混乱，你完全预料不到在多线程环境下，这个方法会给你返回一个什么神奇字符串。 那么又有同学会问，那之前的 Pattern 呢，它就没有线程安全问题吗，我们直接看代码。 12345678910public Matcher matcher(CharSequence input) &#123; if (!compiled) &#123; synchronized(this) &#123; // 双检锁 if (!compiled) compile(); &#125; &#125; Matcher m = new Matcher(this, input); return m;&#125; Pattern.matcher 为了性能，通过 synchronized 关键字使用双检锁方式来检查有限状态机是否编译完毕。因为 Pattern 中并没有任何可修改成员域的方法提供给外部客户端，所以 Pattern 是不可变的，加上返回的是新的 Matcher 实例，所以这个方法在多线程环境下是线程安全的。 聪明的同学可能会注意到，这个 Matcher 才是对标上面的 SimpleDateFormat。Matcher 源码中同样有条类似的注释。 1* Instances of this class are not safe for use by multiple concurrent threads. 最后需要注意的一点是避免无意识的自动装箱 (autoboxing) 操作，例如： 123456private static long sum() &#123; Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum;&#125; 不小心将 l 写成了大写的 L ，本来想声明一个基本类型却声明成了一个包装类型，这导致 sum += i 在疯狂的进行装箱操作。 试着回想一下这一篇的标题，不记得了倒回去看一下。 嗯，避免创建不必要的对象。希望没有让人误解这篇文章在暗示“创建对象都是很昂贵的操作，应该避免创建对象“。相反创建和回收构造函数很少做显示工作的小对象是很廉价的操作，尤其是在现代 JVM 上。通过创建附加的对象，提升程序的清晰性、简洁性和功能性，这通常是件好事。 相反，通过维护自己的对象池 (object pool) 来避免创建对象并不是一件很好的做法，除非池中的对象是非常重量级的。真正需要使用对象池的典型对象就是数据库连接池。建立数据库连接的代价是非常昂贵的，而且数据库会限制你只能用一定的数量连接，因此重用这些对象非常有意义。但是一般来说维护自己的对象池必定会把代码弄的很乱，同时增加内存占用，并损害性能。现代 JVM 实现具有高度优化的 GC，其性能很容易超过轻量级对象池的性能。 与该条目对应的是 (.50) 中的保护性拷贝，当前条目的意思是“当你应该重用一个现有对象时，不要创建新的对象”，而 (.50) 中条目的意思是“当你应该创建一个新的对象时，不要重复使用现有对象”。请注意当保护性拷贝被使用时，重用对象的代价远远大于创建重复对象的代价。必要时如果没能实施保护性拷贝，将会导致潜在的错误和安全漏洞，而创建不必要的对象只会影响程序的风格和性能。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05.依赖注入 (DI) 比硬连接资源 (hardwiring resources) 更可取]]></title>
    <url>%2F2018%2F08%2F24%2F05-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E6%AF%94%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90-hardwiring-resources-%E6%9B%B4%E5%8F%AF%E5%8F%96%2F</url>
    <content type="text"><![CDATA[hardwiring resources，我也不太知道该怎么翻译，跟硬编码 (hard code)可能 有些类似，书中代码的意思是把资源写死在类中（丧失灵活性）或者工具类中修改资源（并发不好控制）。但资源应该通过外部获取而不是直接绑定在工具类中，例如下面这个拼写检查器。 12345678910111213// Dependency injection provides flexibility and testabilitypublic class SpellChecker &#123; private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) &#123; this.dictionary = Objects.requireNonNull(dictionary); &#125; public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;&#125; 可以用任意的 Lexicon 类型的字典传递给构造器得到基于不同的拼写检查器。因为字典不可变特性，多个客户端如果需要完全共享同一个字典，而不用多次实例化这个字典。所以这种模式有一个有用的变体是将资源工厂方法传递给构造方法。工厂是一个可以重复调用创建实例类型的对象，java8 引入的 Supplier&lt;T&gt; 函数接口非常适合代表工厂。通常使用有界通配符类型 (bounded wildcard type) 来约束工厂的入参，例如： Mosic create(Supplier&lt;? extends Tile&gt; tileFactory) 尽管依赖注入很灵活很好测试，但上千依赖的大型项目也有可能因此变得混乱。所以一般项目中都会使用依赖注入框架来解决这些问题，如 Dagger、Guice、Spring 等。注意，以上代码示例中这种用手动为依赖注入的 API 非常适合这些框架的使用。 总之，不要使用单例或静态实用程序类来实现依赖于一个或多个底层资源的类，这些底层资源的行为会影响类的行为，也不要让类直接创建这些资源。相反，将资源或创建资源的工厂传递给构造函数(或静态工厂或构造函数)。这种称为依赖注入的实践将大大增强类的灵活性、可重用性和可测试性。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.用私有构造器实现不可实例化类]]></title>
    <url>%2F2018%2F08%2F21%2F04-%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%8F%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在项目中，我们经常会用到一些工具类 (utility class) ，这些工具类实例化对它们没有任何意义。但是我们知道在缺少显示构造器的情况下，编译器会自动提供一个公有无参数的 default constructor，所以我们显示的提供一个私有构造器即可。 1234567// 工具类，不可实例化public class UtilityClass &#123; private UtilityClass() &#123; throw new AssertionError(); &#125; // ...&#125; 这种习惯用法有一个副作用就是不能被子类化~]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.用私有构造器或枚举类实现单例]]></title>
    <url>%2F2018%2F08%2F21%2F03-%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Singleton(单例) 指的是仅仅只会被实例化一次的类。通常用来表示无状态对象，例如 function (.24) 或本质上唯一的系统组件。这里不打算讲设计模式中单例模式的什么饿汉，懒汉，DCL（双检锁）等等，有兴趣的可以自己上网搜索。 effective java 中提出了三种方法实现 Singleton 。 第一种直接使用公有域。 1234567public class Singleton &#123; public static final Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125;; public void leaveTheBuilder() &#123; //... &#125;&#125; 第二种使用公有静态工厂方法。 12345678910public class Singleton &#123; private static final Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; return INSTANCE; &#125; public void leaveTheBuilding() &#123; //... &#125;&#125; 第二种有个主要优势是可以使用方法引用，例如：Supplier&lt;Singleton&gt; singleton = Singleton::getInstance; 以上两种如果不对私有构造器做处理的话，享有特权的客户端可以借助 AccessibleObject.setAccessible 方法通过反射 (.65) 机制调用私有构造器。如果要防御这种攻击，可以修改私有构造器，在生成第二个对象时抛出异常。这两种如果要实现序列化还比较麻烦，不仅在类声明上需要 “implements Serializable” ，并且必须声明所有的实例域都是瞬时 (transient) 的，还要提供一个 readResolve (.89) 方法。 123private Object readResolve() &#123; return INSTANCE;&#125; 第三种方式是使用单元素枚举类。 123456public enum Singleton &#123; INSTANCE; public void leaveTheBuilding() &#123; //... &#125;&#125; 该方式无偿的提供了序列化机制，并且防止多次实例化，即使面对复杂的序列化或反射攻击的时候。 Josh Bloch 大大给出的结论是，单元素枚举类是实现单例的最佳方法。 但有一点请注意，如果你的单例类需要继承非枚举的超类，那么你就不可以用这个方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.面对多个参数的构造器(Constructor)要考虑使用构建器(Builder)]]></title>
    <url>%2F2018%2F08%2F20%2F02-%E9%9D%A2%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8-Constructor-%E8%A6%81%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8-Builder%2F</url>
    <content type="text"><![CDATA[Builder 模式就不做过多介绍了，在设计那些构造函数或静态工厂有多个参数的类时，构建器模式是一个很好的选择，尤其是当许多参数是可选的或类型相同时。Builder 比 JaveBeans 更安全。 缺点是写起来比较麻烦，好在我们有 Lombok 神器帮我们自动生成。 构建器模式还非常适用类层次结构，下面是一个书中的一个例子： Pizza.java 1234567891011121314151617181920212223242526272829303132package effectivejava.chapter2.item2.hierarchicalbuilder;import java.util.*;// Note that the underlying "simulated self-type" idiom allows for arbitrary fluid hierarchies, not just builderspublic abstract class Pizza &#123; public enum Topping &#123; HAM, MUSHROOM, ONION, PEPPER, SAUSAGE &#125; final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123; EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) &#123; toppings.add(Objects.requireNonNull(topping)); return self(); &#125; abstract Pizza build(); // Subclasses must override this method to return "this" protected abstract T self(); &#125; Pizza(Builder&lt;?&gt; builder) &#123; toppings = builder.toppings.clone(); // See Item 50 &#125;&#125; 注意 Pizza.Builder 是具有递归类型参数的泛型 (.30)，self() 可以正常的返回子类型对象而不需要显示的强制转换，是一种惯用的解决 java 缺乏自我类型的变通方法。 NyPizza.java 12345678910111213141516171819202122232425262728293031323334353637383940package effectivejava.chapter2.item2.hierarchicalbuilder;import java.util.Objects;public class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private final Size size; public Builder(Size size) &#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private NyPizza(Builder builder) &#123; super(builder); size = builder.size; &#125; @Override public String toString() &#123; return "New York Pizza with " + toppings; &#125;&#125; Calzone.java 1234567891011121314151617181920212223242526272829303132333435package effectivejava.chapter2.item2.hierarchicalbuilder;public class Calzone extends Pizza &#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; // Default public Builder sauceInside() &#123; sauceInside = true; return this; &#125; @Override public Calzone build() &#123; return new Calzone(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private Calzone(Builder builder) &#123; super(builder); sauceInside = builder.sauceInside; &#125; @Override public String toString() &#123; return String.format("Calzone with %s and sauce on the %s", toppings, sauceInside ? "inside" : "outside"); &#125;&#125; 注意以上两个子类 Builder 中的 build() 方法，它们都返回了实际的类，这种技术称为协变返回类型( covariant return typing)，允许客户端不需要转换直接使用这些builders，下面看客户端代码。 PizzaTest 12345678910111213141516package effectivejava.chapter2.item2.hierarchicalbuilder;import static effectivejava.chapter2.item2.hierarchicalbuilder.Pizza.Topping.*;import static effectivejava.chapter2.item2.hierarchicalbuilder.NyPizza.Size.*;public class PizzaTest &#123; public static void main(String[] args) &#123; NyPizza pizza = new NyPizza.Builder(SMALL) .addTopping(SAUSAGE).addTopping(ONION).build(); Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInside().build(); System.out.println(pizza); System.out.println(calzone); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.考虑使用静态工厂方法代替构造器]]></title>
    <url>%2F2018%2F08%2F18%2F01-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[优点 有名称 在含有相同签名的多个构造函数的情况下，使用不同名称的静态工厂方法会让API更具可读性。例如：BigInteger 中的一个构造函数 BigInteger(int, int, Random) 返回的 BigInteger 可能为素数，但如果使用 BigInteger.probablePrime 静态工厂方法来表示更为清楚。 不需要每次调用时都创建一个新的对象 允许不可变类 (.17) 使用预先构造的实例，或在构造时将实例缓存起来进行重复利用，从而避免创建不必要的重复对象。 可以返回该类型的任意子类型对象 可以灵活的选择返回该类的对象，一个比较常见的应用是 API 可以返回对象且不会让此对象的类变成公有的，这样可以隐藏实现类，此技术适用于基于接口的框架 (.20) 。在 java8 之前接口不能有静态方法，按照惯例，Type 接口通过不可实例化的 Types 类导出其静态方法，一个具体的列子是 Collection 接口 与 Collections 类。还有一点，这样可以强制让用户通过接口来引用被返回的对象，这通常是最佳实践 (.64) 。在 java8 中接口已经可以含有静态方法，许多静态成员应该被放置在接口本身中。然而，仍有必要将大部分实现代码放在单独包的私有类中而不是接口的静态方法，这是因为 java8 中要求所有静态成员是公开的。java9 允许私有静态方法，但静态字段和静态成员类仍然需要公开。 返回的类可以根据调用参数而进行变化 这点其实是上面那点的引申，参考 EnumSet (.36) ，它没有构造器，只有静态工厂方法，通过参数来决定返回适合当前参数最优的子类，返回的实现类可以随着版本的迭代有多种不同选择，未来如果发现哪个实现类不适合了，完全可以干掉，并且不会对客户端造成任何影响。 在编写静态工厂方法的时候，被返回的实现类不需要存在 这种灵活的静态工厂方法构成了服务提供者框架 的基础，例如 JDBC API。 服务提供者框架 中有三个基础组件： ​ 服务接口 ( service interface ) ：代表实现的服务接口。 ​ 提供者注册API ( provider registration API ) ：提供者用来注册和实现。 ​ 服务访问API ( service access API ) ：客户端用来访问服务实例，允许客户端指定选择实现的标准，如果没有这样的标准，API 会返回默认实现的实例，或允许客户端循环查看所有可用的实现。它是构成服务提供者框架基础的灵活静态工厂。 及一个可选组件： ​ 服务提供者接口 ( service provider interface ) ：描述了产生服务接口实例的工厂对象。在没有此接口的情况下，实现就必须通过反射实例化 对于 JDBC 来说 ，Connection 扮演一部分服务接口角色，DriverManager.registerDriver 是提供者注册API，DriverManager.getConnection 是服务访问 API，Driver 是服务提供者接口。服务提供者框架 模式有很多种变体。例如服务访问API返回比提供者提供的更为丰富的服务接口。这就是桥接模式。依赖注入框架可以被看作是强力服务提供者。java6 平台包含了一个通用的服务提供者框架 java.util.ServiceLoader ，所以你不必，通常也不应该自己写一个。JDBC 没有使用 ServiceLoader 的原因是因为 JDBC 比 ServiceLoader 更早。 缺点 仅提供静态工厂方法的主要限制是没有 public 或 protected 构造器的类无法被子类化 一个类不能被子类化也许会因祸得福，因为它鼓励程序员使用复合代替继承 (.18) ,并且对不可变类型 (.17) 来说这是必须的。 程序员不容易找到它 静态工厂方法和普通的静态方法没有什么区别，很难在 API 脱颖而出，所以程序员不太容易知道这个类是否提供静态工厂方法。可以通过关注类或接口的文档并且遵守命名习惯来弥补。以下是用于静态工厂方法的一些常用名称： from - 一种类型转换方法，通过一个参数返回对应类的实例，例如： 1Date d = Date.from(instant); of - 一种聚合方法，通过多个参数并返回包含这种参数的类型，例如： 1Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf - 一种比 from 和 of 更为冗长的方案，例如： 1BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); intance or getInstance - 返回由其参数（如果有）描述的实例，但不能说该实例与参数具有相同的值，例如： 1StackWalker luke = StackWalker.getInstance(options); create or newInstance - 同上，除了保证每个调用都会返回一个新的实例，例如： 1Object newArray = Array.newInstance(classObject, arrayLen); getType - 类似 getInstance ，但一般不是在该类中定义。Type 代表该静态工厂方法返回的对象类型，例如： 1FileStore fs = Files.getFileStore(path); newType - 同上，但保证会返回一个新的实例，例如： 1BufferedReader br = Files.newBufferedReader(path); type - 一个简单的 getType 和 newType 的替代方案，例如： 1List&lt;Complain&gt; litany = Collections.list(legacyLitany); 总之，静态工厂方法更可取，所以要避免第一反应就提供公共构造器而不首先考虑静态工厂方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>effective java</tag>
        <tag>note</tag>
        <tag>0x01.创建和销毁对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test5]]></title>
    <url>%2F2017%2F06%2F11%2FTest5%2F</url>
    <content type="text"><![CDATA[2017-6-11 14:53:23 。。。。。]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>